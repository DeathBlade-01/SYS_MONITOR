#!/usr/bin/bash

declare cpu_current=()
declare cpu_prev=()
declare -A mem_values=()


bar="|"
empty="."	

below_20_color=$'\e[38;5;42m'
below_40_color=$'\e[38;5;119m'
below_60_color=$'\e[38;5;227m'
below_80_color=$'\e[38;5;208m'
below_100_color=$'\e[38;5;196m'
perc_color=$'\e[38;5;39m'
cpu_color=$'\e[38;5;199m'
cpu_clock_color=$'\e[38;5;184m'

reset_color=$'\e[0m'
dim_color=$'\e[2m'
bold_color=$'\e[1m'
color1=$'\e[38;5;34m'

background_color_1=$'\e[48;5;24m'
background_color_2=$'\e[48;5;114m'
background_color_3=$'\e[48;5;177m'

foreground_color_1=$'\e[38;5;232m'


num_cpus=0

copy-data(){
	cpu_prev=()

	local key value

	for key in "${!cpu_current[@]}"; do 
		value=${cpu_current[$key]}
		cpu_prev[$key]=$value
	done
}

read-mem(){
	local total free avail_for_app buffers cache swap_cached 
	local key value_raw value rest
	while IFS=: read -r key value_raw; do 
		read -r value rest <<< "$value_raw"
		case $key in
			MemTotal) mem_values["total"]=$value;;
			MemFree) mem_values["free"]=$value;;
			MemAvailable) mem_values["avail_for_app"]=$value;;
			Cached) mem_values["cache"]=$value;;


			SwapTotal) mem_values["swap_total"]=$value;;
			SwapFree) mem_values["swap_free"]=$value;;
			SwapCached) mem_values["swap_cached"]=$value;;
		esac
	done < /proc/meminfo
	#declare -p mem_values
}
#TODO: ADD cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq for cpu_freq
read-cpu(){
	local cpu user nice system idle iowait irq softirq steal guest guest_nice
	local busy # NO NEED FOR IDLE TIME VAR, REUSED idle
	
	local clocks
	#VERY IMP < < indicates awk process is getting subbed here
	mapfile -t clocks < <(awk '/cpu MHz/{print $4}' /proc/cpuinfo)	

	while read -r cpu user nice system idle iowait irq softirq steal guest guest_nice; do
		
		if [[ $cpu != cpu* ]]; then
			break
		elif [[ $cpu == cpu ]];then
			continue
		fi

		local num=${cpu#cpu}
		busy=$((user + nice + system + irq + softirq + steal + guest + guest_nice))
		# echo "[DEBUG]: idle : $idle iowait: $iowait"
		idle=$((idle + iowait))
		#echo "[DEBUG]: idle : $idle"
		#echo "[DEBUG]: ${clocks[$num]}"	
		local value="$busy $idle ${clocks[$num]}"	
		cpu_current[$num]=$value	
		
		
	done < /proc/stat
	
	
	printf "%s\n" "${clocks[@]}"	
}
init_cpu(){
	local cpu val
	while read -r cpu val; do
		if [[ $cpu != cpu* ]]; then
			break
		elif [[ $cpu == cpu ]];then
			continue
		fi

		((num_cpus++))
	done < /proc/stat
}


print-bar(){
	
	local key=$1
	local core_offset=$2
	local temp freq	
	local busy1 idle1 busy2 idle2
	read -r busy1 idle1 temp <<< "${cpu_prev[$key]}"
	read -r busy2 idle2 freq <<< "${cpu_current[$key]}"

	local busy=$((busy2-busy1))
	local idle=$((idle2-idle1))

	local total=$((busy + idle))
	freq=${freq%.*}
	
	#echo "[DEBUG]: $busy $idle $freq"	
	local gigs=$((freq/1000))
	local megs=$(((freq%1000)/10))
	local usage=$((1000*busy/total))

	local integer=$((usage/10))
	local float=$((usage%10))
	local term_size


	term_size=$(stty size </dev/tty 2>&1) || return

	local term_lines=${term_size%% *}
	local term_cols=${term_size##* }
		
	local length=$((term_cols-20)) #[] and 100 and % + for cpu and .0 and 2 spaces , 4+2 for CPU CLOCK
	if (($num_cpus>9)); then
		((length--))
	fi
	local num_bars=$((usage * length/ 1000))
	local s='['
	local i=0


	local color_choosen

	if (( $integer<20 )); then
		color_choosen=$below_20_color
	elif (( $integer<40)); then
		color_choosen=$below_40_color
	elif (( $integer<60)); then
		color_choosen=$below_60_color
	elif (( $integer<80)); then
		color_choosen=$below_80_color
	else
		color_choosen=$below_100_color
	fi
	for(( i=0;i<num_bars;i++)); do
		s+=$bar
	done

	for(( i=$num_bars;i<$length;i++)); do
		s+=$empty
	done
	s+="]"	
	printf -v s "%s%s%s " "$color_choosen" "$s" "$reset_color"

	printf -v perc '%s%d.%d%%%s' "$perc_color" "$integer" "$float" "$reset_color"
	s+="$perc"
	printf -v key '%scpu%d %s%d.%2dG%s' "$cpu_color" "$key" "$cpu_clock_color" "$gigs" "$megs" "$reset_color"

	{
	#Save Cursor Locn
	printf '\e7'

	#Move Cursor to bottom
	printf '\e[%d;%dH' "$((LINES-num_cpus+core_offset+1))" 0 #TO COUNTERACT ZERO NUMBERING

	#Clear the Line
	printf '\e[0K'

	#Print the progress
	printf "%s %s" "$key" "$s">&2
	
	#Reset Cursor
	printf '\e8'

	#reset colour of terminal
	printf '\e[0m'	
	} >/dev/tty 2>&1
}
init_term(){
	
	local term_size
	term_size=$(stty size </dev/tty 2>&1) || return
	local term_lines=${term_size%% *}
	
	{
		
	#enable alt buffer
	printf '\e[?1049h'
	#hide cursor
	printf '\e[?25l'
	#Move the cursor back home
	printf '\e[H'

	
	#MOVE CURSOR BACK UP to PREVENT CTRL C err
	#printf '\e[%dA' "$((num_cpus+4))"

	#save cursor locn
	printf '\e7'
	
	
	#set scrollable region --> syntax \e[(top);(bottom)r
	printf '\e[%d;%dr' 0 "$((term_lines-num_cpus-11-8))" # 3 FOR CPU HEADER 3 FOR MEM STATS 2 FOR MEM-BARS 3 FOR MEM HEADER
	
	#restore cursor location
	printf '\e8'
	
	} >/dev/tty 2>&1
}
deinit_term(){
	local term_size
	term_size=$(stty size </dev/tty 2>&1) || return
	local term_lines=${term_size%% *}
	
	{
	
	#save the cursor Locn
	printf '\e7'
	for ((i=0;i<num_cpus+6;i++)); do
		printf '\e[%d;%dH' "$((term_lines-num_cpus-6+i))" 0
		printf '\e[0K'
	done

	#RESET SCROLLABLE
	printf '\e[%d;%dr' 0 "$term_lines"

	
	#Reset the cursor Locn
	printf '\e8'
	

	#Make cursor visible
	printf '\e[?25h'

	#disable Alternate buffer
	printf '\e[?1049l'	


	} >/dev/tty 2>&1
}
visualise-data(){
	local key
	local core_num=0

	#move to the top
	printf '\e[0;0H'	

	local now
	printf -v now '%(DATE: %Y-%m-%d \t TIME: %H:%M:%S%z)T'

	echo -e  "${dim_color}CPU USAGE ON ${color1}$HOSTNAME ${reset_color}\t ${dim_color}$now ${reset_color}" 
	local term_size
	term_size=$(stty size </dev/tty 2>&1) || return
	local term_lines=${term_size%% *}
	
	#if (( $term_lines > 20 )); then
	#	echo "HELLO"
	#fi
	visualise-mem
	visualise-cache
	
	for key in "${!cpu_current[@]}"; do
		print-bar "$key" "$core_num"
		((core_num++))
	done	
}
# INPUT 20 FOR MEM STATS, and X for SWAP STATS
print-mem(){
	local perc

	local available_memory=$1
	local total_memory=$2
	local usage=$((1000*available_memory/total_memory))

	local integer=$((usage/10))
	local float=$((usage%10))
	local term_size


	term_size=$(stty size </dev/tty 2>&1) || return

	local term_lines=${term_size%% *}
	local term_cols=${term_size##* }
	
	local length=$((term_cols-$3)) #[] and 100 and % + for cpu and .0 and 2 spaces
	local num_bars=$((usage * length/ 1000))
	local s='['
	local i=0


	local color_choosen

	if (( $integer<20 )); then
		color_choosen=$below_100_color
	elif (( $integer<40)); then
		color_choosen=$below_80_color
	elif (( $integer<60)); then
		color_choosen=$below_60_color
	elif (( $integer<80)); then
		color_choosen=$below_40_color
	else
		color_choosen=$below_20_color
	fi
	for(( i=0;i<num_bars;i++)); do
		s+=$bar
	done

	for(( i=$num_bars;i<$length;i++)); do
		s+=$empty
	done
	s+="]"	
	printf -v s "%s%s%s " "$color_choosen" "$s" "$reset_color"

	printf -v perc '%s%d.%d%%%s' "$perc_color" "$integer" "$float" "$reset_color"
	s+="$perc"
	echo "$s"
}
visualise-cache(){
	
	local available_memory=$((mem_values["swap_free"]))
	local total_memory=$((mem_values["swap_total"]))
	local key1 bar1 key2 bar2
	
	bar1="$(print-mem $available_memory $total_memory 24)"
	printf -v key1 '%sAvailable Swap%s' "$cpu_color" "$reset_color"
	mem_values["swap_used"]=$((mem_values["swap_total"] - mem_values["swap_free"]))

	{
	#Save Cursor Locn
	printf '\e7'

	#Move Cursor to bottom
	printf '\e[%d;%dH' "$((LINES-num_cpus-9-7))" 0 # 7 for CPU INFO + BUFFER(1) + BOTTOM LINE

	#Clear the Line
	printf '\e[0K'
	
	#PRINT THE TITLE
	print-title "SWAP STATS" "$foreground_color_1" "$background_color_1"
	printf '\n'
	#echo 

	#Print the progress
	printf "%s %s" "$key1" "$bar1">&2

	#PRINT STATS
	local gigs=$((mem_values["swap_total"]/1000000))
	local megs=$(( ( (mem_values["swap_total"]/1000 )% 1000) /10 ))
	echo	
	printf "\n%sTotal: %s%3d.%02dG%s"  "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color" 

	gigs=$((mem_values["swap_used"]/1000000))
	megs=$(( ( (mem_values["swap_used"]/1000 )% 1000) /10 ))
	printf "\t\t%sUsed: %s%3d.%02dG%s" "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color"  	

	gigs=$((mem_values["swap_cached"]/1000))
	megs=$(( ( (mem_values["swap_cached"])% 1000)/10 ))
	printf "\n%sCached: %s%3d.%02dM%s" "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color"   	

	gigs=$((mem_values["swap_free"]/1000000))
	megs=$(( ( (mem_values["swap_free"]/1000 )% 1000) /10 ))
	printf "\t\t%sFree: %s%3d.%02dG%s\n" "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color"  	
	
	echo $s

	#Reset Cursor
	printf '\e8'

	#reset colour of terminal
	printf '\e[0m'	
	} >/dev/tty 2>&1


}
visualise-mem(){
	
	local available_memory=$((mem_values["avail_for_app"]))
	local total_memory=$((mem_values["total"]))
	local key1 bar1 key2 bar2
	
	bar1="$(print-mem $available_memory $total_memory 19)"
	printf -v key1 '%sAvailable%s' "$cpu_color" "$reset_color"




	available_memory=$((mem_values["free"]))
	total_memory=$((mem_values["avail_for_app"]))
	mem_values["used"]=$((mem_values["total"] - mem_values["avail_for_app"]))

	bar2="$(print-mem $available_memory $total_memory 19)"

	printf -v key2 '%sFree     %s' "$cpu_color" "$reset_color"

	# OBTAIN RAM INFO
	local line ram_speed
	mapfile -t line < RAM_INFO || exit
	ram_speed="${line[0]}"
	{
	#Save Cursor Locn
	printf '\e7'

	#Move Cursor to bottom
	printf '\e[%d;%dH' "$((LINES-num_cpus-9))" 0 # 7 for CPU INFO + BUFFER(1) + BOTTOM LINE

	#Clear the Line
	printf '\e[0K'
	
	#PRINT THE TITLE
	print-title "MEM STATS: CLOCK SPEED: ${ram_speed}" "$foreground_color_1" "$background_color_1"
	printf '\n'
	#echo 

	#Print the progress
	printf "%s %s\n" "$key1" "$bar1">&2
	printf "%s %s" "$key2" "$bar2">&2

	#PRINT STATS
	local gigs=$((mem_values["total"]/1000000))
	local megs=$(( ( (mem_values["total"]/1000 )% 1000) /10 ))
	echo	
	printf "\n%sTotal:     %s%3d.%02dG%s"  "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color" 

	gigs=$((mem_values["used"]/1000000))
	megs=$(( ( (mem_values["used"]/1000 )% 1000) /10 ))
	printf "\t%sUsed: %s%3d.%02dG%s" "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color"  	

	gigs=$((mem_values["avail_for_app"]/1000000))
	megs=$(( ( (mem_values["avail_for_app"]/1000 )% 1000) /10 ))
	printf "\n%sAvailable: %s%3d.%02dG%s" "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color"   	

	gigs=$((mem_values["free"]/1000000))
	megs=$(( ( (mem_values["free"]/1000 )% 1000) /10 ))
	printf "\t%sFree: %s%3d.%02dG%s\n" "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color"  	
	
	local cpu_name=$(awk -F : '/model name/{print $2; exit}' /proc/cpuinfo | sed 's/^ *//' | sed 's/CPU //')
	echo $s

	print-title "CPU STATS: $cpu_name" "$foreground_color_1" "$background_color_1"	
	#Reset Cursor
	printf '\e8'

	#reset colour of terminal
	printf '\e[0m'	
	} >/dev/tty 2>&1


}

visualise-mem-2(){
		
	local perc

	local available_memory=$((mem_values["avail_for_app"]))
	local total_memory=$((mem_values["total"]))
	local usage=$((1000*available_memory/total_memory))

	local integer=$((usage/10))
	local float=$((usage%10))
	local term_size


	term_size=$(stty size </dev/tty 2>&1) || return

	local term_lines=${term_size%% *}
	local term_cols=${term_size##* }
	
	local length=$((term_cols-20)) #[] and 100 and % + for cpu and .0 and 2 spaces
	local num_bars=$((usage * length/ 1000))
	local bar1='['
	local i=0

	
	local color_choosen

	if (( $integer<20 )); then
		color_choosen=$below_20_color
	elif (( $integer<40)); then
		color_choosen=$below_40_color
	elif (( $integer<60)); then
		color_choosen=$below_60_color
	elif (( $integer<80)); then
		color_choosen=$below_80_color
	else
		color_choosen=$below_100_color
	fi
	for(( i=0;i<num_bars;i++)); do
		bar1+=$bar
	done

	for(( i=$num_bars;i<$length;i++)); do
		bar1+=$empty
	done
	bar1+="]"	
	printf -v bar1 "%s%s%s " "$color_choosen" "$bar1" "$reset_color"

	printf -v perc '%s%d.%d%%%s' "$perc_color" "$integer" "$float" "$reset_color"
	bar1+="$perc"
	local key1


	printf -v key1 '%sAvailable%s' "$cpu_color" "$reset_color"




	available_memory=$((mem_values["avail_for_app"]-mem_values["free"]))
	total_memory=$((mem_values["avail_for_app"]))
	usage=$((1000*available_memory/total_memory))
	mem_values["used"]=$((mem_values["total"] - mem_values["avail_for_app"]))


	integer=$((100-(usage/10)))
	float=$((10-(usage%10)))
	
	num_bars=$((usage * length/ 1000))
	local bar2='['
	i=0


	

	if (( $integer<20 )); then
		color_choosen=$below_100_color
	elif (( $integer<40)); then
		color_choosen=$below_80_color
	elif (( $integer<60)); then
		color_choosen=$below_60_color
	elif (( $integer<80)); then
		color_choosen=$below_40_color
	else
		color_choosen=$below_20_color
	fi
	for(( i=0;i<num_bars;i++)); do
		bar2+=$bar
	done

	for(( i=$num_bars;i<$length;i++)); do
		bar2+=$empty
	done
	bar2+="]"	
	printf -v bar2 "%s%s%s " "$color_choosen" "$bar2" "$reset_color"

	printf -v perc '%s%d.%d%%%s' "$perc_color" "$integer" "$float" "$reset_color"
	bar2+="$perc"
	local key2


	printf -v key2 '%sFree     %s' "$cpu_color" "$reset_color"


	{
	#Save Cursor Locn
	printf '\e7'

	#Move Cursor to bottom
	printf '\e[%d;%dH' "$((LINES-num_cpus-6))" 0

	#Clear the Line
	printf '\e[0K'

	#Print the progress
	printf "%s %s\n" "$key1" "$bar1">&2
	printf "%s %s" "$key2" "$bar2">&2

	#PRINT STATS
	local gigs=$((mem_values["total"]/1000000))
	local megs=$(( ( (mem_values["total"]/1000 )% 1000) /10 ))
	echo	
	
	printf "\n%sTotal:     %s%d.%dG%s"  "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color" 
	
	gigs=$((mem_values["used"]/1000000))
	megs=$(( ( (mem_values["used"]/1000 )% 1000) /10 ))
	printf "\t%sUsed:      %s%d.%dG%s" "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color"  	

	gigs=$((mem_values["avail_for_app"]/1000000))
	megs=$(( ( (mem_values["avail_for_app"]/1000 )% 1000) /10 ))
	#printf "\n%sAvailable: %s%d.%05dG%s" "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color"   	
	printf "\nAvailable: %d.%02dG" "$gigs" "$megs"   	

	gigs=$((mem_values["free"]/1000000))
	megs=$(( ( (mem_values["free"]/1000 )% 1000) /10 ))
	printf "\t%sFree:      %s%d.%dG%s\n" "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color"

	#Reset Cursor
	printf '\e8'

	#reset colour of terminal
	printf '\e[0m'	
	} >/dev/tty 2>&1

}
print-title(){
	local bg_color=$3
	local font_color=$2
	#MOVE CURSOR BACK TO FIRST COL
	printf '\e[1G'
	

	#CHANGE BG COLOR
	printf "%s" $bg_color

	#GO TO END OF LINE WITH SPACES
	printf '\e[0K'
	
	#CHANGE FG COLOR
	printf "%s" $font_color
	
	#PRINT THE TITLE
	printf "%s" "$1" #ALWAYS QUOTE IT TO AVOID INTELi37020U ERROR1
	
	#RESET FORMAT
	printf "%s" $reset_color

	#MOVE CURSOR DOWN
	printf '\n'


}
dummy(){
	local line ram_speed
	mapfile -t line < RAM_INFO || exit
	echo "${line[0]}"
	echo "Helo $ram_speed"
}
main(){
	dummy
	print-title "TERMINAL" $foreground_color_1 $background_color_1
	read-mem
	read-cpu
	init_cpu
	local sleep_delay
	#echo "${bold_color}[DEBUG:] Waiting for Data${reset_color}" >&2
	local OPTIND OPTARG opt


	while getopts 's:' opt; do
		case "$opt" in
			s) sleep_delay=$OPTARG;;
		esac
	done
	shopt -s checkwinsize
	#TO ENSURE LINES AND COLUMNS ARE SET
	(:)
	
	#echo "${bold_color}[DEBUG:] Waiting for Data (monitoring $num_cpus cores)${reset_color}" >&2
	sleep $sleep_delay 
	trap deinit_term exit
	trap init_term WINCH
	init_term
	

	while true; do	
		copy-data
		read-cpu
		read-mem
		visualise-data
		sleep $sleep_delay 
	done
	
	
}

main $@
