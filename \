#!/usr/bin/bash

declare cpu_current=()
declare cpu_prev=()
declare -A disk_info=()
declare -A mem_values=()
declare -A network_current=()
declare -A network_previous=()

bar="|"
empty="."	

danger_color=$'\e[38;5;42m'
semi_danger_color=$'\e[38;5;119m'
okay_color=$'\e[38;5;227m'
safe_color=$'\e[38;5;208m'
very_safe_color=$'\e[38;5;196m'


perc_color=$'\e[38;5;39m'
cpu_color=$'\e[38;5;199m'
cpu_clock_color=$'\e[38;5;184m'

reset_color=$'\e[0m'
dim_color=$'\e[2m'
bold_color=$'\e[1m'

color1=$'\e[38;5;34m'
default_color=$'\e[39m'


background_color_3=$'\e[48;5;69m'
background_color_1=$'\e[48;5;24m'
background_color_4=$'\e[48;5;177m'
background_color_5=$'\e[48;5;103m'
background_color_2=$'\e[48;5;95m'

foreground_color_3=$'\e[38;5;15m'
foreground_color_1=$'\e[38;5;232m' #BEST
foreground_color_2=$'\e[38;5;17m'

declare num_cpus=0
copy_cpu_data(){
	cpu_prev=()

	local key value

	for key in "${!cpu_current[@]}"; do 
		value=${cpu_current[$key]}
		cpu_prev[$key]=$value
	done
}

read_mem_and_cache(){
	local total free avail_for_app buffers cache swap_cached 
	local key value_raw value rest
	while IFS=: read -r key value_raw; do 
		read -r value rest <<< "$value_raw"
		case $key in
			MemTotal) mem_values["total"]=$value;;
			MemFree) mem_values["free"]=$value;;
			MemAvailable) mem_values["avail_for_app"]=$value;;
			Cached) mem_values["cache"]=$value;;


			SwapTotal) mem_values["swap_total"]=$value;;
			SwapFree) mem_values["swap_free"]=$value;;
			SwapCached) mem_values["swap_cached"]=$value;;
		esac
	done < /proc/meminfo
	#declare -p mem_values
}

read_cpu(){
	local cpu user nice system idle iowait irq softirq steal guest guest_nice
	local busy # NO NEED FOR IDLE TIME VAR, REUSED idle
	
	local clocks

	#VERY IMP < < indicates awk process is getting subbed here
	mapfile -t clocks < <(awk '/cpu MHz/{print $4}' /proc/cpuinfo)	

	while read -r cpu user nice system idle iowait irq softirq steal guest guest_nice; do
		
		if [[ $cpu != cpu* ]]; then
			break
		elif [[ $cpu == cpu ]];then
			continue
		fi

		local num=${cpu#cpu}
		busy=$((user + nice + system + irq + softirq + steal + guest + guest_nice))
		idle=$((idle + iowait))
		

		# echo "[DEBUG]: idle : $idle iowait: $iowait"
		#echo "[DEBUG]: idle : $idle"
		#echo "[DEBUG]: ${clocks[$num]}"	
		local value="$busy $idle ${clocks[$num]}"	
		cpu_current[$num]=$value	
		
		
	done < /proc/stat
		
}
init_cpu(){
	local cpu val
	while read -r cpu val; do
		if [[ $cpu != cpu* ]]; then
			break
		elif [[ $cpu == cpu ]];then
			continue
		fi

		((num_cpus++))
	done < /proc/stat
}


print_bar_for_cpu(){
	
	local key=$1
	local core_offset=$2
	local temp freq	
	local busy1 idle1 busy2 idle2
	read -r busy1 idle1 temp <<< "${cpu_prev[$key]}"
	read -r busy2 idle2 freq <<< "${cpu_current[$key]}"

	local busy=$((busy2-busy1))
	local idle=$((idle2-idle1))

	local total=$((busy + idle))
	freq=${freq%.*}
	
	#echo "[DEBUG]: $busy $idle $freq"	
	local gigs=$((freq/1000))
	local megs=$(((freq%1000)/10))
	local usage=$((1000*busy/total))

	local integer=$((usage/10))
	local float=$((usage%10))
	local term_size


	term_size=$(stty size </dev/tty 2>&1) || return

	local term_lines=${term_size%% *}
	local term_cols=${term_size##* }
		
	local length=$((term_cols-22)) #[] and 100 and % + for cpu and .0 and 2 spaces , 4+2+2 for CPU CLOCK
	if (($num_cpus>9)); then
		((length--))
	fi
	local num_bars=$((usage * length/ 1000))
	local s='['
	local i=0


	local color_choosen

	if (( $integer<20 )); then
		color_choosen=$danger_color
	elif (( $integer<40)); then
		color_choosen=$semi_danger_color
	elif (( $integer<60)); then
		color_choosen=$okay_color
	elif (( $integer<80)); then
		color_choosen=$safe_color
	else
		color_choosen=$very_safe_color
	fi
	for(( i=0;i<num_bars;i++)); do
		s+=$bar
	done

	for(( i=$num_bars;i<$length;i++)); do
		s+=$empty
	done
	s+="]"	
	printf -v s "%s%s%s " "$color_choosen" "$s" "$reset_color"

	printf -v perc '%s%d.%d%%%s' "$perc_color" "$integer" "$float" "$reset_color"
	s+="$perc"
	printf -v key '%scpu%d %s%d.%2dGHz%s' "$cpu_color" "$key" "$cpu_clock_color" "$gigs" "$megs" "$reset_color"

	{
	#Save Cursor Locn
	printf '\e7'

	#Move Cursor to bottom
	printf '\e[%d;%dH' "$((LINES-num_cpus+core_offset+1))" 0 #TO COUNTERACT ZERO NUMBERING

	#Clear the Line
	printf '\e[0K'

	#Print the progress
	printf "%s %s" "$key" "$s">&2
	
	#Reset Cursor
	printf '\e8'

	#reset colour of terminal
	printf '\e[0m'	
	} >/dev/tty 2>&1
}

init_term(){
	
	local term_size
	term_size=$(stty size </dev/tty 2>&1) || return
	local term_lines=${term_size%% *}
	
	{
		
	#enable alt buffer
	printf '\e[?1049h'
	#hide cursor
	printf '\e[?25l'
	#Move the cursor back home
	printf '\e[H'

	
	#MOVE CURSOR BACK UP to PREVENT CTRL C err
	#printf '\e[%dA' "$((num_cpus+4))"

	#save cursor locn
	printf '\e7'
	
	
	#set scrollable region --> syntax \e[(top);(bottom)r
	#printf '\e[%d;%dr' 1 1 
	
	#restore cursor location
	printf '\e8'
	
	} >/dev/tty 2>&1
}

deinit_term(){
	#local term_size
	#term_size=$(stty size </dev/tty 2>&1) || return
	#local term_lines=${term_size%% *}
	
	{
	
	#save the cursor Locn
	#printf '\e7'
	#for ((i=0;i<num_cpus+6;i++)); do
	#	printf '\e[%d;%dH' "$((term_lines-num_cpus-6+i))" 0
	#	printf '\e[0K'
	#done
#
#	#RESET SCROLLABLE
#	printf '\e[%d;%dr' 0 "$term_lines"
#
#	
#	#Reset the cursor Locn
#	printf '\e8'
#	
#
	#Make cursor visible
	printf '\e[?25h'

	#disable Alternate buffer
	printf '\e[?1049l'	


	} >/dev/tty 2>&1
}
visualise_data(){
	
	#move to the top
	printf '\e[0;0H'

	#MOVE TO FIRST COL
	printf '\e[1G'
	

	#CHANGE BG COLOR
	printf "%s" $background_color_1

	#GO TO END OF LINE WITH SPACES
	printf '\e[0K'
	
	
	local now
	{
		printf -v now '%(DATE: %Y-%m-%d \t TIME: %H:%M:%S%z)T'
		echo -e  "${dim_color}${foreground_color_2}SYSTEM MONITORING ON: ${bold_color}$HOSTNAME" 
		local term_size
		term_size=$(stty size </dev/tty 2>&1) || return
		local term_lines=${term_size%% *}
		local term_cols=${term_size##* }
		
		#if (( $term_lines > 20 )); then
		#	echo "HELLO"
		#fi
		if (( $term_cols > 75 && $term_lines > 35)); then
			visualise_network $1
		fi

		if (( $term_lines > 30)); then
			visualise_disk
		fi
		if (( $term_lines > 22)); then
			visualise_cache
		fi
		if (( $term_lines > 15)); then
			visualise_memory
		fi
		if (( $term_lines > 7)); then
			visualise_cpu	
		fi
	}> >(cat >/dev/tty 2>&1)
}

visualise_cpu(){

	local key
	local core_num=0
	
	local cpu_name=$(awk -F : '/model name/{print $2; exit}' /proc/cpuinfo | sed 's/^ *//' | sed 's/CPU //')
	echo $s
	

	#Move Cursor to bottom
	printf '\e[%d;%dH' "$((LINES-num_cpus-1))" 0 #TO COUNTERACT ZERO NUMBERING
	print-title "${bold_color}CPU STATS: $cpu_name" "$foreground_color_1" "$background_color_1"	

	for key in "${!cpu_current[@]}"; do
		print_bar_for_cpu "$key" "$core_num"
		((core_num++))
	done	
}
# INPUT 20 FOR MEM STATS, and X for SWAP STATS
print_bar_chart_generic(){
	local perc

	local available_memory=$1
	local total_memory=$2
	local usage=$((1000*available_memory/total_memory))

	local integer=$((usage/10))
	local float=$((usage%10))
	local term_size


	term_size=$(stty size </dev/tty 2>&1) || return

	local term_lines=${term_size%% *}
	local term_cols=${term_size##* }
	
	local length=$((term_cols-$3)) #[] and 100 and % + for cpu and .0 and 2 spaces
	local num_bars=$((usage * length/ 1000))
	local s='['
	local i=0


	local color_choosen

	if (( $integer<20 )); then
		color_choosen=$very_safe_color
	elif (( $integer<40)); then
		color_choosen=$safe_color
	elif (( $integer<60)); then
		color_choosen=$okay_color
	elif (( $integer<80)); then
		color_choosen=$semi_danger_color
	else
		color_choosen=$danger_color
	fi
	for(( i=0;i<num_bars;i++)); do
		s+=$bar
	done

	for(( i=$num_bars;i<$length;i++)); do
		s+=$empty
	done
	s+="]"	
	printf -v s "%s%s%s " "$color_choosen" "$s" "$reset_color"

	printf -v perc '%s%d.%d%%%s' "$perc_color" "$integer" "$float" "$reset_color"
	s+="$perc"
	echo "$s"
}
visualise_cache(){
	
	local available_memory=$((mem_values["swap_free"]))
	local total_memory=$((mem_values["swap_total"]))
	local key1 bar1 key2 bar2
	
	bar1="$(print_bar_chart_generic $available_memory $total_memory 24)"
	printf -v key1 '%sAvailable Swap%s' "$cpu_color" "$reset_color"
	mem_values["swap_used"]=$((mem_values["swap_total"] - mem_values["swap_free"]))

	{
	#Save Cursor Locn
	printf '\e7'

	#Move Cursor to bottom
	printf '\e[%d;%dH' "$((LINES-num_cpus-9-7))" 0 # 7 for CPU INFO + BUFFER(1) + BOTTOM LINE

	#Clear the Line
	printf '\e[0K'
	
	#PRINT THE TITLE
	print-title "${bold_color}SWAP STATS" "$foreground_color_1" "$background_color_1"
	printf '\n'
	#echo 

	#Print the progress
	printf "%s %s" "$key1" "$bar1">&2

	#PRINT STATS
	local gigs=$((mem_values["swap_total"]/1000000))
	local megs=$(( ( (mem_values["swap_total"]/1000 )% 1000) /10 ))
	echo	
	printf "\n%s%-8s%s%3d.%02dG%s"  "$cpu_color" "Total: " "$perc_color" "$gigs" "$megs" "$reset_color" 

	gigs=$((mem_values["swap_used"]/1000000))
	megs=$(( ( (mem_values["swap_used"]/1000 )% 1000) /10 ))
	printf "%s%18s%s%3d.%02dG%s" "$cpu_color" "Used: " "$perc_color" "$gigs" "$megs" "$reset_color"  	

	gigs=$((mem_values["swap_cached"]/1000))
	megs=$(( ( (mem_values["swap_cached"])% 1000)/10 ))
	printf "\n%s%-8s%s%3d.%02dM%s" "$cpu_color" "Cached: " "$perc_color" "$gigs" "$megs" "$reset_color"   	

	gigs=$((mem_values["swap_free"]/1000000))
	megs=$(( ( (mem_values["swap_free"]/1000 )% 1000) /10 ))
	printf "%s%18s%s%3d.%02dG%s\n" "$cpu_color" "Free: "  "$perc_color" "$gigs" "$megs" "$reset_color"  	
	
	echo $s

	#Reset Cursor
	printf '\e8'

	#reset colour of terminal
	printf '\e[0m'	
	} >/dev/tty 2>&1


}
visualise_memory(){
	
	local available_memory=$((mem_values["avail_for_app"]))
	local total_memory=$((mem_values["total"]))
	local key1 bar1 key2 bar2
	
	bar1="$(print_bar_chart_generic $available_memory $total_memory 19)"
	printf -v key1 '%sAvailable%s' "$cpu_color" "$reset_color"




	available_memory=$((mem_values["free"]))
	total_memory=$((mem_values["avail_for_app"]))
	mem_values["used"]=$((mem_values["total"] - mem_values["avail_for_app"]))

	bar2="$(print_bar_chart_generic $available_memory $total_memory 19)"

	printf -v key2 '%sFree     %s' "$cpu_color" "$reset_color"

	# OBTAIN RAM INFO
	local line ram_speed
	mapfile -t line < RAM_INFO || exit
	ram_speed="${line[0]}"
	{
	#Save Cursor Locn
	printf '\e7'

	#Move Cursor to bottom
	printf '\e[%d;%dH' "$((LINES-num_cpus-9))" 0 # 7 for CPU INFO + BUFFER(1) + BOTTOM LINE

	#Clear the Line
	printf '\e[0K'
	
	#PRINT THE TITLE
	print-title "${bold_color}MEM STATS: CLOCK SPEED: ${ram_speed}" "$foreground_color_1" "$background_color_1"
	printf '\n'
	#echo 

	#Print the progress
	printf "%s %s\n" "$key1" "$bar1">&2
	printf "%s %s\n" "$key2" "$bar2">&2
	
	#PRINT STATS 
	local gigs=$((mem_values["total"]/1000000)) 
	local megs=$(( ( (mem_values["total"]/1000 )% 1000) /10 )) 
	echo
	printf "%s%-12s%s%3d.%02dG%s"  "$cpu_color" "Total: " "$perc_color" "$gigs" "$megs" "$reset_color"  

	gigs=$((mem_values["used"]/1000000)) 
	megs=$(( ( (mem_values["used"]/1000 )% 1000) /10 )) 
	printf "%s%18s%s%3d.%02dG%s" "$cpu_color" "Used: " "$perc_color" "$gigs" "$megs" "$reset_color"  	 

	gigs=$((mem_values["avail_for_app"]/1000000)) 
	megs=$(( ( (mem_values["avail_for_app"]/1000 )% 1000) /10 )) 
	printf "\n%s%-12s%s%3d.%02dG%s" "$cpu_color" "Available: " "$perc_color" "$gigs" "$megs" "$reset_color"   	 


	gigs=$((mem_values["free"]/1000000)) 
	megs=$(( ( (mem_values["free"]/1000 )% 1000) /10 )) 
	printf "%s%18s%s%3d.%02dG%s\n" "$cpu_color" "Free: " "$perc_color" "$gigs" "$megs" "$reset_color"  	 



	#Reset Cursor
	printf '\e8'

	#reset colour of terminal
	printf '\e[0m'	
	} >/dev/tty 2>&1


}

#OLD DEPRACATED METHOD
visualise_memory-2(){
		
	local perc

	local available_memory=$((mem_values["avail_for_app"]))
	local total_memory=$((mem_values["total"]))
	local usage=$((1000*available_memory/total_memory))

	local integer=$((usage/10))
	local float=$((usage%10))
	local term_size


	term_size=$(stty size </dev/tty 2>&1) || return

	local term_lines=${term_size%% *}
	local term_cols=${term_size##* }
	
	local length=$((term_cols-20)) #[] and 100 and % + for cpu and .0 and 2 spaces
	local num_bars=$((usage * length/ 1000))
	local bar1='['
	local i=0

	
	local color_choosen

	if (( $integer<20 )); then
		color_choosen=$danger_color
	elif (( $integer<40)); then
		color_choosen=$semi_danger_color
	elif (( $integer<60)); then
		color_choosen=$okay_color
	elif (( $integer<80)); then
		color_choosen=$safe_color
	else
		color_choosen=$very_safe_color
	fi
	for(( i=0;i<num_bars;i++)); do
		bar1+=$bar
	done

	for(( i=$num_bars;i<$length;i++)); do
		bar1+=$empty
	done
	bar1+="]"	
	printf -v bar1 "%s%s%s " "$color_choosen" "$bar1" "$reset_color"

	printf -v perc '%s%d.%d%%%s' "$perc_color" "$integer" "$float" "$reset_color"
	bar1+="$perc"
	local key1


	printf -v key1 '%sAvailable%s' "$cpu_color" "$reset_color"




	available_memory=$((mem_values["avail_for_app"]-mem_values["free"]))
	total_memory=$((mem_values["avail_for_app"]))
	usage=$((1000*available_memory/total_memory))
	mem_values["used"]=$((mem_values["total"] - mem_values["avail_for_app"]))


	integer=$((100-(usage/10)))
	float=$((10-(usage%10)))
	
	num_bars=$((usage * length/ 1000))
	local bar2='['
	i=0


	

	if (( $integer<20 )); then
		color_choosen=$very_safe_color
	elif (( $integer<40)); then
		color_choosen=$safe_color
	elif (( $integer<60)); then
		color_choosen=$okay_color
	elif (( $integer<80)); then
		color_choosen=$semi_danger_color
	else
		color_choosen=$danger_color
	fi
	for(( i=0;i<num_bars;i++)); do
		bar2+=$bar
	done

	for(( i=$num_bars;i<$length;i++)); do
		bar2+=$empty
	done
	bar2+="]"	
	printf -v bar2 "%s%s%s " "$color_choosen" "$bar2" "$reset_color"

	printf -v perc '%s%d.%d%%%s' "$perc_color" "$integer" "$float" "$reset_color"
	bar2+="$perc"
	local key2


	printf -v key2 '%sFree     %s' "$cpu_color" "$reset_color"


	{
	#Save Cursor Locn
	printf '\e7'

	#Move Cursor to bottom
	printf '\e[%d;%dH' "$((LINES-num_cpus-6))" 0

	#Clear the Line
	printf '\e[0K'

	#Print the progress
	printf "%s %s\n" "$key1" "$bar1">&2
	printf "%s %s" "$key2" "$bar2">&2

	#PRINT STATS
	local gigs=$((mem_values["total"]/1000000))
	local megs=$(( ( (mem_values["total"]/1000 )% 1000) /10 ))
	echo	
	
	printf "\n%sTotal:     %s%d.%dG%s"  "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color" 
	
	gigs=$((mem_values["used"]/1000000))
	megs=$(( ( (mem_values["used"]/1000 )% 1000) /10 ))
	printf "\t%sUsed:      %s%d.%dG%s" "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color"  	

	gigs=$((mem_values["avail_for_app"]/1000000))
	megs=$(( ( (mem_values["avail_for_app"]/1000 )% 1000) /10 ))
	#printf "\n%sAvailable: %s%d.%05dG%s" "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color"   	
	printf "\nAvailable: %d.%02dG" "$gigs" "$megs"   	

	gigs=$((mem_values["free"]/1000000))
	megs=$(( ( (mem_values["free"]/1000 )% 1000) /10 ))
	printf "\t%sFree:      %s%d.%dG%s\n" "$cpu_color" "$perc_color" "$gigs" "$megs" "$reset_color"

	#Reset Cursor
	printf '\e8'

	#reset colour of terminal
	printf '\e[0m'	
	} >/dev/tty 2>&1

}
read_disk_info(){
	local disk_name disk_type disk_space
	
	local root_disk=$(lsblk -no PKNAME "$(findmnt -n -o SOURCE /)") #FIND BASED ON PKey 
	
	if (( ${#disk_info[@]} == 0)); then
		local i=1
		local entry

		while read -r disk_type disk_name disk_space is_hard_disk; do
			
			entry+="$disk_name -- $disk_space " 
			if (( $is_hard_disk == 1 ));then
				entry+="HDD"
			elif [[ $disk_type == sda* ]]; then 
				entry+="SSD"
			else
				entry+="NVME"
			fi



			if [[ $disk_type == "${root_disk}" ]]; then
				disk_info[0]="${entry}"
			else
				disk_info[i++]="${entry}"
			fi
		
		done< <(lsblk -d -n -e7 -o NAME,MODEL,SIZE,ROTA )
	fi

}
visualise_disk(){
	#local disk_cmd="df -h / | tail -n 1" #WONT WORK AS df -h / | tail all gets passed as args of df only
	local root_disk_size root_disk_used root_disk_avail
	read -r root_disk_size root_disk_used root_disk_avail < <(df -h / | tail -n 1| awk '{print $2 $3 $4; exit}' | sed 's/G/ /g')

	bar1="$(print_bar_chart_generic $root_disk_avail $root_disk_size 25)"
	printf -v key1 '%sFree Root Space%s' "$cpu_color" "$reset_color"



	local home_disk_size home_disk_used home_disk_avail
	read -r home_disk_size home_disk_used home_disk_avail < <(df -h /home | tail -n 1| awk '{print $2 $3 $4; exit}' | sed 's/G/ /g')

	bar2="$(print_bar_chart_generic $home_disk_avail $home_disk_size 25)"
	printf -v key2 '%s%sFree Home Space%s' "$cpu_color" "$bold_color" "$reset_color"

	{
	#Save Cursor Locn
	printf '\e7'

	#Move Cursor to bottom
	printf '\e[%d;%dH' "$((LINES-num_cpus-9-7-8))" 0 # 7 for CPU INFO + BUFFER(1) + BOTTOM LINE

	#Clear the Line
	printf '\e[0K'

	#PRINT THE TITLE
	print-title "${bold_color}DISK STATS: [ROOT] ${bold_color}${disk_info[0]} " "$foreground_color_1" "$background_color_1"
	printf '\n'
	#echo 

	#Print the progress
	printf "%s %s\n" "$key1" "$bar1">&2
	printf "%s %s" "$key2" "$bar2">&2
	
	
	#PRINT STATS
	echo	
	
	printf "\n%s%-8s%s%dG%s" "$cpu_color" "Total Root: " "$perc_color" "$root_disk_size" "$reset_color" 
#	printf "\n%sTotal Root: %s%dG%s"  "$cpu_color" "$perc_color" "$root_disk_size" "$reset_color" 
	printf "%17s%-8s%s%dG%s"  "$cpu_color" "Used Root: " "$perc_color" "$root_disk_used" "$reset_color"  	
	printf "%17s%-8s%s%dG%s"  "$cpu_color" "Free Root: " "$perc_color" "$root_disk_avail" "$reset_color"  	

	
	printf "\n%s%-8s%s%dG%s"  "$cpu_color" "Total Home: " "$perc_color" "$home_disk_size" "$reset_color" 
	printf "%17s%-8s%s%dG%s"  "$cpu_color" "Used Home: " "$perc_color" "$home_disk_used" "$reset_color"  	
	printf "%17s%-8s%s%dG%s"  "$cpu_color" "Free Home: " "$perc_color" "$home_disk_avail" "$reset_color"  	
	
	echo 
	#Reset Cursor
	printf '\e8'

	#reset colour of terminal
	printf '\e[0m'	
	} >/dev/tty 2>&1
}
read_network(){
	local rec_bytes _ trans_bytes interface values
	while IFS=: read -r interface values; do 
		interface=${interface##* }
		#echo "[DEBUG]: interface: $interface HELLO"		
		if [[ $interface == lo* || $interface == lxcbr* ]]; then
			continue 
		fi
		
		local state=$(cat /sys/class/net/$interface/operstate)
		read -r rec_bytes _ _ _ _ _ _ _ trans_bytes _ <<< "$values"
		state+=" $rec_bytes $trans_bytes"	
		network_current[$interface]=$state
		
	done < <(tail -n +3 /proc/net/dev)
		
}
copy_network_data(){
	network_previous=()

	local key value

	for key in "${!network_current[@]}"; do 
		value=${network_current[$key]}
		network_previous[$key]=$value
	done
}

visualise_network(){
	
	local key	
	local recv_p recv_n trans_p trans_n stat temp
	local time=$1
	local up_color=$'\e[38;5;46m'
	local down_color=$'\e[38;5;196m'
	local output
	
	for key in "${!network_current[@]}"; do 
		local str	
		read -r temp recv_p trans_p <<< "${network_previous[$key]}"
		read -r stat recv_n trans_n <<< "${network_current[$key]}"
		local recv_rate trans_rate
		local prefix

		if [[ $key =~ ^wl ]]; then 
			printf -v prefix "%s%-10s %s" "$bold_color" "[WIFI]" "$reset_color" 
		elif [[ $key =~ ^enp ]]; then 
			printf -v prefix "%s%-10s %s" "$bold_color" "[ETHERNET]" "$reset_color" 
		else
			:	
		fi

		if [[ $stat == down ]]; then
			recv_rate=0
			trans_rate=0
			#printf -v str "%s%s:\t RECV RATE:%d\tTRANSFER RATE:%d%s" 
			printf -v str "%s%s%-7s%s%s: STATUS: DOWN %s" "$down_color" "$prefix" "$down_color" "$key" "$down_color" "$reset_color"
		else

			local recv=$((recv_n-recv_p))
			local trans=$((trans_n-trans_p))

			recv_rate=$(( recv / time))
			trans_rate=$(( trans/ time))
			
			local recv_rate_kilo=$(( recv_rate/1000 ))
			local recv_rate_bits=$(( (recv_rate%1000)/10 ))
			
			local trans_rate_kilo=$((trans_rate/1000))
			local trans_rate_bits=$(( (trans_rate%1000)/10 ))
			#if [[ $key =~ ^wl ]]; then
			#	grep "^${key}:" /proc/net/wireless
			#fi
			printf -v str "%s%s%-7s%s%s: RECV RATE:%d.%03d KB/s     TRANSFER RATE:%d.%03d KB/s%s" "$up_color" "$prefix" "$up_color"  "$key" "$up_color" "$recv_rate_kilo" "$recv_rate_bits" "$trans_rate_kilo" "$trans_rate_bits" "$reset_color"

		fi
		output+="$str"
		output+=$'\n'
	done
	local term_size


	{
	#Save Cursor Locn
	printf '\e7'

	#Move Cursor to bottom
	
	if (( ${#network_current[@]} > 4 )); then
		printf '\e[%d;%dH' "$((LINES-num_cpus-9-7-9-7))" 0 #TO COUNTERACT ZERO NUMBERING
	else
		printf '\e[%d;%dH' "$((LINES-num_cpus-9-7-9- ${#network_current[@]}- 2 ))" 0 #TO COUNTERACT ZERO NUMBERING
	fi
	#PRINT TITLE
	if (( ${#network_current[@]} > 4 )); then
		print-title "NETWORK STATS: [TOP5]" "$foreground_color_1" "$background_color_1"
	else
		print-title "NETWORK STATS: " "$foreground_color_1" "$background_color_1"
	fi
	echo
	
	#Clear the Line
	printf '\e[0K'

	#Print the progress
	printf "%s" "$output" >&2
	
	#Reset Cursor
	printf '\e8'

	#reset colour of terminal
	printf '\e[0m'	
	} >/dev/tty 2>&1
}

copy_and_read_data(){
	copy_cpu_data
	copy_network_data

	read_cpu
	read_network
	read_mem_and_cache
}

print-title(){
	local bg_color=$3
	local font_color=$2
	#MOVE CURSOR BACK TO FIRST COL
	printf '\e[1G'
	

	#CHANGE BG COLOR
	printf "%s" $bg_color

	#GO TO END OF LINE WITH SPACES
	printf '\e[0K'
	
	#CHANGE FG COLOR
	printf "%s" $font_color
	
	#PRINT THE TITLE
	printf "%s" "$1" #ALWAYS QUOTE IT TO AVOID INTELi37020U ERROR1
	
	#RESET FORMAT
	printf "%s" $reset_color

	#MOVE CURSOR DOWN
	printf '\n'


}
init_systems(){
	read_disk_info
	read_cpu
	init_cpu
}
main(){
	#declare -p disk_info 
	local sleep_delay
	#echo "${bold_color}[DEBUG:] Waiting for Data${reset_color}" >&2
	local OPTIND OPTARG opt


	while getopts 's:' opt; do
		case "$opt" in
			s) sleep_delay=$OPTARG;;
		esac
	done
	shopt -s checkwinsize
	#TO ENSURE LINES AND COLUMNS ARE SET
	(:)
	init_systems
	#echo "${bold_color}[DEBUG:] Waiting for Data (monitoring $num_cpus cores)${reset_color}" >&2
	sleep $sleep_delay 
	trap deinit_term exit
	trap init_term WINCH
	init_term
	
	
	while true; do	
	
		copy_and_read_data
		visualise_data $sleep_delay
		#declare -p network_previous
		#declare -p network_current
		sleep $sleep_delay 

	done
	
	
}

main $@
